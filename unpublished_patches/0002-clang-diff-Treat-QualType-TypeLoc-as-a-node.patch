From 1744a57498676e7c6ff90abba73316972b9111f4 Mon Sep 17 00:00:00 2001
From: Johannes Altmanninger <aclopte@gmail.com>
Date: Thu, 17 Aug 2017 19:15:29 +0200
Subject: [PATCH 2/5] [clang-diff] Treat QualType / TypeLoc as a node

---
 lib/Tooling/ASTDiff/ASTDiff.cpp        | 46 ++++++++++++++++++++++------------
 test/Tooling/clang-diff-ast.cpp        | 45 +++++++++++++++++++++------------
 test/Tooling/clang-diff-basic.cpp      |  9 ++++---
 test/Tooling/clang-diff-bottomup.cpp   | 24 ++++++++----------
 test/Tooling/clang-diff-heuristics.cpp |  6 ++---
 test/Tooling/clang-diff-html.test      |  8 +++---
 test/Tooling/clang-diff-json.cpp       |  5 ++--
 test/Tooling/clang-diff-opt.cpp        |  8 +++---
 test/Tooling/clang-diff-topdown.cpp    | 34 +++++++++++++------------
 9 files changed, 107 insertions(+), 78 deletions(-)

diff --git a/lib/Tooling/ASTDiff/ASTDiff.cpp b/lib/Tooling/ASTDiff/ASTDiff.cpp
index 5b2cc15fc4..381bcee3b7 100644
--- a/lib/Tooling/ASTDiff/ASTDiff.cpp
+++ b/lib/Tooling/ASTDiff/ASTDiff.cpp
@@ -1,1312 +1,1326 @@
 //===- ASTDiff.cpp - AST differencing implementation-----------*- C++ -*- -===//
 //
 //                     The LLVM Compiler Infrastructure
 //
 // This file is distributed under the University of Illinois Open Source
 // License. See LICENSE.TXT for details.
 //
 //===----------------------------------------------------------------------===//
 //
 // This file contains definitons for the AST differencing interface.
 //
 //===----------------------------------------------------------------------===//
 
 #include "clang/Tooling/ASTDiff/ASTDiff.h"
 
 #include "clang/AST/DataCollection.h"
 #include "clang/AST/DeclVisitor.h"
 #include "clang/AST/LexicallyOrderedRecursiveASTVisitor.h"
 #include "clang/AST/StmtVisitor.h"
+#include "clang/AST/TypeVisitor.h"
 #include "clang/Lex/Lexer.h"
 #include "llvm/ADT/PriorityQueue.h"
 #include "llvm/Support/MD5.h"
 
 #include <limits>
 #include <memory>
 #include <unordered_set>
 
 using namespace llvm;
 using namespace clang;
 
 namespace clang {
 namespace diff {
 
 namespace {
 /// Maps nodes of the left tree to ones on the right, and vice versa.
 class Mapping {
 public:
   Mapping() = default;
   Mapping(Mapping &&Other) = default;
   Mapping &operator=(Mapping &&Other) = default;
 
   Mapping(size_t Size) {
     SrcToDst = llvm::make_unique<NodeId[]>(Size);
     DstToSrc = llvm::make_unique<NodeId[]>(Size);
   }
 
   void link(NodeId Src, NodeId Dst) {
     SrcToDst[Src] = Dst, DstToSrc[Dst] = Src;
   }
 
   NodeId getDst(NodeId Src) const { return SrcToDst[Src]; }
   NodeId getSrc(NodeId Dst) const { return DstToSrc[Dst]; }
   bool hasSrc(NodeId Src) const { return getDst(Src).isValid(); }
   bool hasDst(NodeId Dst) const { return getSrc(Dst).isValid(); }
 
 private:
   std::unique_ptr<NodeId[]> SrcToDst, DstToSrc;
 };
 } // end anonymous namespace
 
 class ASTDiff::Impl {
 public:
   SyntaxTree::Impl &T1, &T2;
   Mapping TheMapping;
 
   Impl(SyntaxTree::Impl &T1, SyntaxTree::Impl &T2,
        const ComparisonOptions &Options);
 
   /// Matches nodes one-by-one based on their similarity.
   void computeMapping();
 
   // Compute Change for each node based on similarity.
   void computeChangeKinds(Mapping &M);
 
   NodeId getMapped(const std::unique_ptr<SyntaxTree::Impl> &Tree,
                    NodeId Id) const {
     if (&*Tree == &T1)
       return TheMapping.getDst(Id);
     assert(&*Tree == &T2 && "Invalid tree.");
     return TheMapping.getSrc(Id);
   }
 
 private:
   // Returns true if the two subtrees are identical.
   bool identical(NodeId Id1, NodeId Id2) const;
 
   // Returns false if the nodes must not be mached.
   bool isMatchingPossible(NodeId Id1, NodeId Id2) const;
 
   // Returns true if the nodes' parents are matched.
   bool haveSameParents(const Mapping &M, NodeId Id1, NodeId Id2) const;
 
   // Uses an optimal albeit slow algorithm to compute a mapping between two
   // subtrees, but only if both have fewer nodes than MaxSize.
   void addOptimalMapping(Mapping &M, NodeId Id1, NodeId Id2) const;
 
   // Computes the ratio of common descendants between the two nodes.
   // Descendants are only considered to be equal when they are mapped in M.
   double getJaccardSimilarity(const Mapping &M, NodeId Id1, NodeId Id2) const;
 
   double getNodeSimilarity(const Mapping &M, NodeId Id1, NodeId Id2) const;
 
   // Returns the node that has the highest degree of similarity.
   NodeId findCandidate(const Mapping &M, NodeId Id1) const;
 
   NodeId findCandidateFromChildren(const Mapping &M, NodeId Id1,
                                    NodeId P2) const;
 
   // Returns a mapping of identical subtrees.
   Mapping matchTopDown() const;
 
   // Tries to match any yet unmapped nodes, in a bottom-up fashion.
   void matchBottomUp(Mapping &M) const;
 
   // Matches nodes, whose parents are matched.
   void matchChildren(Mapping &M);
 
   const ComparisonOptions &Options;
 
   friend class ZhangShashaMatcher;
 };
 
 using HashType = std::array<uint8_t, 16>;
 
 /// Represents the AST of a TranslationUnit.
 class SyntaxTree::Impl {
 public:
   Impl(SyntaxTree *Parent, ASTUnit &AST);
   /// Constructs a tree from an AST node.
   Impl(SyntaxTree *Parent, Decl *N, ASTUnit &AST);
   Impl(SyntaxTree *Parent, Stmt *N, ASTUnit &AST);
   template <class T>
   Impl(SyntaxTree *Parent,
        typename std::enable_if<std::is_base_of<Stmt, T>::value, T>::type *Node,
        ASTUnit &AST)
       : Impl(Parent, dyn_cast<Stmt>(Node), AST) {}
   template <class T>
   Impl(SyntaxTree *Parent,
        typename std::enable_if<std::is_base_of<Decl, T>::value, T>::type *Node,
        ASTUnit &AST)
       : Impl(Parent, dyn_cast<Decl>(Node), AST) {}
   explicit Impl(SyntaxTree *Parent, const Impl &Other);
 
   SyntaxTree *Parent;
   ASTUnit &AST;
   PrintingPolicy TypePP;
   /// Nodes in preorder.
   std::vector<Node> Nodes;
   std::vector<NodeId> Leaves;
   // Maps preorder indices to postorder ones.
   std::vector<int> PostorderIds;
   std::vector<NodeId> NodesBfs;
   std::map<NodeId, SourceRange> TemplateArgumentLocations;
 
   int getSize() const { return Nodes.size(); }
   NodeId getRootId() const { return 0; }
   PreorderIterator begin() const { return getRootId(); }
   PreorderIterator end() const { return getSize(); }
 
   const Node &getNode(NodeId Id) const { return Nodes[Id]; }
   Node &getMutableNode(NodeId Id) { return Nodes[Id]; }
   bool isValidNodeId(NodeId Id) const { return Id >= 0 && Id < getSize(); }
   void addNode(Node &N) { Nodes.push_back(N); }
   int getNumberOfDescendants(NodeId Id) const;
   bool isInSubtree(NodeId Id, NodeId SubtreeRoot) const;
   int findPositionInParent(NodeId Id, bool Shifted = false) const;
 
   std::string getRelativeName(const NamedDecl *ND,
                               const DeclContext *Context) const;
   std::string getRelativeName(const NamedDecl *ND) const;
 
   std::string getNodeValue(NodeId Id) const;
   std::string getNodeValue(const Node &Node) const;
   std::string getDeclValue(const Decl *D) const;
   std::string getStmtValue(const Stmt *S) const;
 
   HashType hashNode(const Node &N) const;
 
   SourceRange getSourceRange(const Node &N) const;
 
 private:
   void initTree();
   void setLeftMostDescendants();
 };
 
 static bool isSpecializedNodeExcluded(const Decl *D) { return D->isImplicit(); }
 static bool isSpecializedNodeExcluded(const Stmt *S) { return false; }
 static bool isSpecializedNodeExcluded(CXXCtorInitializer *I) {
   return !I->isWritten();
 }
 static bool isSpecializedNodeExcluded(const TemplateArgumentLoc *S) {
   return false;
 }
+static bool isNodeExcluded(ASTUnit &AST, QualType QT) { return false; }
 
 static bool isNodeExcluded(ASTUnit &AST, TemplateName *Template) {
   // TODO what if it is from another file
   return false;
 }
 
 template <class T> static bool isNodeExcluded(ASTUnit &AST, T *N) {
   const SourceManager &SrcMgr = AST.getSourceManager();
   if (!N)
     return true;
   SourceLocation SLoc = N->getSourceRange().getBegin();
   if (SLoc.isValid()) {
     // Ignore everything from other files.
     if (!SrcMgr.isInMainFile(SLoc))
       return true;
     const Preprocessor &PP = AST.getPreprocessor();
     if (SLoc.isMacroID() && !PP.isAtStartOfMacroExpansion(SLoc))
       return true;
   }
   return isSpecializedNodeExcluded(N);
 }
 
 static SourceRange getSourceExtent(const ASTUnit &AST, SourceRange Range) {
   const SourceManager &SrcMgr = AST.getSourceManager();
   SourceLocation BeginLoc = Range.getBegin();
   SourceLocation EndLoc;
   if (BeginLoc.isMacroID())
     EndLoc = SrcMgr.getExpansionRange(BeginLoc).second;
   else
     EndLoc = Range.getEnd();
   EndLoc = Lexer::getLocForEndOfToken(EndLoc, /*Offset=*/0, SrcMgr,
                                       AST.getLangOpts());
   return {SrcMgr.getExpansionLoc(BeginLoc), SrcMgr.getExpansionLoc(EndLoc)};
 }
 
 namespace {
 // Sets Height, Parent and Children for each node.
 struct PreorderVisitor
     : public LexicallyOrderedRecursiveASTVisitor<PreorderVisitor> {
   using BaseType = LexicallyOrderedRecursiveASTVisitor<PreorderVisitor>;
 
   int Id = 0, Depth = 0;
   NodeId Parent;
   SyntaxTree::Impl &Tree;
 
   PreorderVisitor(SyntaxTree::Impl &Tree)
       : BaseType(Tree.AST.getSourceManager()), Tree(Tree) {}
 
   template <class T> std::tuple<NodeId, NodeId> PreTraverse(const T &ASTNode) {
     NodeId MyId = Id;
     Tree.Nodes.emplace_back();
     Node &N = Tree.getMutableNode(MyId);
     N.Parent = Parent;
     N.Depth = Depth;
     N.ASTNode = DynTypedNode::create(ASTNode);
     assert(!N.ASTNode.getNodeKind().isNone() &&
            "Expected nodes to have a valid kind.");
     if (Parent.isValid()) {
       Node &P = Tree.getMutableNode(Parent);
       P.Children.push_back(MyId);
     }
     Parent = MyId;
     ++Id;
     ++Depth;
     return std::make_tuple(MyId, Tree.getNode(MyId).Parent);
   }
   void PostTraverse(std::tuple<NodeId, NodeId> State) {
     NodeId MyId, PreviousParent;
     std::tie(MyId, PreviousParent) = State;
     assert(MyId.isValid() && "Expecting to only traverse valid nodes.");
     Parent = PreviousParent;
     --Depth;
     Node &N = Tree.getMutableNode(MyId);
     N.RightMostDescendant = Id - 1;
     assert(N.RightMostDescendant >= 0 &&
            N.RightMostDescendant < Tree.getSize() &&
            "Rightmost descendant must be a valid tree node.");
     if (N.isLeaf())
       Tree.Leaves.push_back(MyId);
     N.Height = 1;
     for (NodeId Child : N.Children)
       N.Height = std::max(N.Height, 1 + Tree.getNode(Child).Height);
   }
   bool TraverseDecl(Decl *D) {
     if (isNodeExcluded(Tree.AST, D))
       return true;
     auto SavedState = PreTraverse(*D);
     BaseType::TraverseDecl(D);
     PostTraverse(SavedState);
     return true;
   }
   bool TraverseStmt(Stmt *S) {
     if (S)
       S = S->IgnoreImplicit();
     if (isNodeExcluded(Tree.AST, S))
       return true;
     auto SavedState = PreTraverse(*S);
     BaseType::TraverseStmt(S);
     PostTraverse(SavedState);
     return true;
   }
-  bool TraverseType(QualType T) { return true; }
+  bool TraverseTypeLoc(TypeLoc TL) {
+    auto SavedState = PreTraverse(TL);
+    BaseType::TraverseTypeLoc(TL);
+    PostTraverse(SavedState);
+    return true;
+  }
+  bool TraverseType(QualType QT) {
+    if (isNodeExcluded(Tree.AST, QT))
+      return true;
+    auto SavedState = PreTraverse(QT);
+    BaseType::TraverseType(QT);
+    PostTraverse(SavedState);
+    return true;
+  }
   bool TraverseConstructorInitializer(CXXCtorInitializer *Init) {
     if (isNodeExcluded(Tree.AST, Init))
       return true;
     auto SavedState = PreTraverse(*Init);
     BaseType::TraverseConstructorInitializer(Init);
     PostTraverse(SavedState);
     return true;
   }
   bool TraverseTemplateArgumentLoc(const TemplateArgumentLoc &ArgLoc) {
     if (isNodeExcluded(Tree.AST, &ArgLoc))
       return true;
     Tree.TemplateArgumentLocations.emplace(Id, ArgLoc.getSourceRange());
     auto SavedState = PreTraverse(ArgLoc.getArgument());
     BaseType::TraverseTemplateArgumentLoc(ArgLoc);
     PostTraverse(SavedState);
     return true;
   }
   bool TraverseTemplateName(TemplateName Template) {
     if (isNodeExcluded(Tree.AST, &Template))
       return true;
     auto SavedState = PreTraverse(Template);
     BaseType::TraverseTemplateName(Template);
     PostTraverse(SavedState);
     return true;
   }
 };
 } // end anonymous namespace
 
 SyntaxTree::Impl::Impl(SyntaxTree *Parent, ASTUnit &AST)
     : Parent(Parent), AST(AST), TypePP(AST.getLangOpts()) {
   TypePP.AnonymousTagLocations = false;
 }
 
 SyntaxTree::Impl::Impl(SyntaxTree *Parent, Decl *N, ASTUnit &AST)
     : Impl(Parent, AST) {
   PreorderVisitor PreorderWalker(*this);
   PreorderWalker.TraverseDecl(N);
   initTree();
 }
 
 SyntaxTree::Impl::Impl(SyntaxTree *Parent, Stmt *N, ASTUnit &AST)
     : Impl(Parent, AST) {
   PreorderVisitor PreorderWalker(*this);
   PreorderWalker.TraverseStmt(N);
   initTree();
 }
 
 SyntaxTree::Impl::Impl(SyntaxTree *Parent, const Impl &Other)
     : Impl(Parent, Other.AST) {
   Nodes = Other.Nodes;
   Leaves = Other.Leaves;
   PostorderIds = Other.PostorderIds;
   NodesBfs = Other.NodesBfs;
   TemplateArgumentLocations = TemplateArgumentLocations;
 }
 
 static std::vector<NodeId> getSubtreePostorder(const SyntaxTree::Impl &Tree,
                                                NodeId Root) {
   std::vector<NodeId> Postorder;
   std::function<void(NodeId)> Traverse = [&](NodeId Id) {
     const Node &N = Tree.getNode(Id);
     for (NodeId Child : N.Children)
       Traverse(Child);
     Postorder.push_back(Id);
   };
   Traverse(Root);
   return Postorder;
 }
 
 static std::vector<NodeId> getSubtreeBfs(const SyntaxTree::Impl &Tree,
                                          NodeId Root) {
   std::vector<NodeId> Ids;
   size_t Expanded = 0;
   Ids.push_back(Root);
   while (Expanded < Ids.size())
     for (NodeId Child : Tree.getNode(Ids[Expanded++]).Children)
       Ids.push_back(Child);
   return Ids;
 }
 
 void SyntaxTree::Impl::initTree() {
   setLeftMostDescendants();
   int PostorderId = 0;
   PostorderIds.resize(getSize());
   std::function<void(NodeId)> PostorderTraverse = [&](NodeId Id) {
     for (NodeId Child : getNode(Id).Children)
       PostorderTraverse(Child);
     PostorderIds[Id] = PostorderId;
     ++PostorderId;
   };
   PostorderTraverse(getRootId());
   NodesBfs = getSubtreeBfs(*this, getRootId());
 }
 
 void SyntaxTree::Impl::setLeftMostDescendants() {
   for (NodeId Leaf : Leaves) {
     getMutableNode(Leaf).LeftMostDescendant = Leaf;
     NodeId Parent, Cur = Leaf;
     while ((Parent = getNode(Cur).Parent).isValid() &&
            getNode(Parent).Children[0] == Cur) {
       Cur = Parent;
       getMutableNode(Cur).LeftMostDescendant = Leaf;
     }
   }
 }
 
 int SyntaxTree::Impl::getNumberOfDescendants(NodeId Id) const {
   return getNode(Id).RightMostDescendant - Id + 1;
 }
 
 bool SyntaxTree::Impl::isInSubtree(NodeId Id, NodeId SubtreeRoot) const {
   return Id >= SubtreeRoot && Id <= getNode(SubtreeRoot).RightMostDescendant;
 }
 
 int SyntaxTree::Impl::findPositionInParent(NodeId Id, bool Shifted) const {
   NodeId Parent = getNode(Id).Parent;
   if (Parent.isInvalid())
     return 0;
   const auto &Siblings = getNode(Parent).Children;
   int Position = 0;
   for (size_t I = 0, E = Siblings.size(); I < E; ++I) {
     if (Shifted)
       Position += getNode(Siblings[I]).Shift;
     if (Siblings[I] == Id) {
       Position += I;
       return Position;
     }
   }
   llvm_unreachable("Node not found in parent's children.");
 }
 
 // Returns the qualified name of ND. If it is subordinate to Context,
 // then the prefix of the latter is removed from the returned value.
 std::string
 SyntaxTree::Impl::getRelativeName(const NamedDecl *ND,
                                   const DeclContext *Context) const {
   std::string Val = ND->getQualifiedNameAsString();
   std::string ContextPrefix;
   if (!Context)
     return Val;
   if (auto *Namespace = dyn_cast<NamespaceDecl>(Context))
     ContextPrefix = Namespace->getQualifiedNameAsString();
   else if (auto *Record = dyn_cast<RecordDecl>(Context))
     ContextPrefix = Record->getQualifiedNameAsString();
   else if (AST.getLangOpts().CPlusPlus11)
     if (auto *Tag = dyn_cast<TagDecl>(Context))
       ContextPrefix = Tag->getQualifiedNameAsString();
   // Strip the qualifier, if Val refers to somthing in the current scope.
   // But leave one leading ':' in place, so that we know that this is a
   // relative path.
   if (!ContextPrefix.empty() && StringRef(Val).startswith(ContextPrefix))
     Val = Val.substr(ContextPrefix.size() + 1);
   return Val;
 }
 
 std::string SyntaxTree::Impl::getRelativeName(const NamedDecl *ND) const {
   return getRelativeName(ND, ND->getDeclContext());
 }
 
 static const DeclContext *getEnclosingDeclContext(ASTUnit &AST, const Stmt *S) {
   while (S) {
     const auto &Parents = AST.getASTContext().getParents(*S);
     if (Parents.empty())
       return nullptr;
     const auto &P = Parents[0];
     if (const auto *D = P.get<Decl>())
       return D->getDeclContext();
     S = P.get<Stmt>();
   }
   return nullptr;
 }
 
 static std::string getInitializerValue(const CXXCtorInitializer *Init,
                                        const PrintingPolicy &TypePP) {
   if (Init->isAnyMemberInitializer())
     return Init->getAnyMember()->getName();
   if (Init->isBaseInitializer())
     return QualType(Init->getBaseClass(), 0).getAsString(TypePP);
   if (Init->isDelegatingInitializer())
     return Init->getTypeSourceInfo()->getType().getAsString(TypePP);
   llvm_unreachable("Unknown initializer type");
 }
 
 template <class T> static std::string dumpToString(const T &Object) {
   std::string Str;
   llvm::raw_string_ostream OS(Str);
   Object.dump(OS);
   return OS.str();
 }
 
 std::string SyntaxTree::Impl::getNodeValue(NodeId Id) const {
   return getNodeValue(getNode(Id));
 }
 
 std::string SyntaxTree::Impl::getNodeValue(const Node &N) const {
   const DynTypedNode &DTN = N.ASTNode;
   if (N.isMacro()) {
     CharSourceRange Range(getSourceExtent(AST, N.ASTNode.getSourceRange()),
                           false);
     return Lexer::getSourceText(Range, AST.getSourceManager(),
                                 AST.getLangOpts());
   }
   if (auto *S = DTN.get<Stmt>())
     return getStmtValue(S);
   if (auto *D = DTN.get<Decl>())
     return getDeclValue(D);
+  if (auto *TL = DTN.get<TypeLoc>())
+    return TL->getType().getAsString();
+  if (auto *QT = DTN.get<QualType>())
+    return QT->getAsString();
   if (auto *Init = DTN.get<CXXCtorInitializer>())
     return getInitializerValue(Init, TypePP);
   if (auto *Template = DTN.get<TemplateName>())
     return dumpToString(*Template);
   if (auto *Arg = DTN.get<TemplateArgument>())
-    return dumpToString(*Arg);
+    return "";
   llvm_unreachable("getNodeValue: unhandled AST node.\n");
 }
 
 std::string SyntaxTree::Impl::getDeclValue(const Decl *D) const {
-  std::string Value;
-  if (auto *V = dyn_cast<ValueDecl>(D))
-    return getRelativeName(V) + "(" + V->getType().getAsString(TypePP) + ")";
-  if (auto *N = dyn_cast<NamedDecl>(D))
-    Value += getRelativeName(N) + ";";
-  if (auto *T = dyn_cast<TypedefNameDecl>(D))
-    return Value + T->getUnderlyingType().getAsString(TypePP) + ";";
-  if (auto *T = dyn_cast<TypeDecl>(D))
-    if (T->getTypeForDecl())
-      Value +=
-          T->getTypeForDecl()->getCanonicalTypeInternal().getAsString(TypePP) +
-          ";";
   if (auto *U = dyn_cast<UsingDirectiveDecl>(D))
     return U->getNominatedNamespace()->getName();
+  if (auto *N = dyn_cast<NamedDecl>(D))
+    return getRelativeName(N);
   if (auto *A = dyn_cast<AccessSpecDecl>(D)) {
     CharSourceRange Range(A->getSourceRange(), false);
     return Lexer::getSourceText(Range, AST.getSourceManager(),
                                 AST.getLangOpts());
   }
-  return Value;
+  return "";
 }
 
 std::string SyntaxTree::Impl::getStmtValue(const Stmt *S) const {
   if (auto *U = dyn_cast<UnaryOperator>(S))
     return UnaryOperator::getOpcodeStr(U->getOpcode());
   if (auto *B = dyn_cast<BinaryOperator>(S))
     return B->getOpcodeStr();
   if (auto *M = dyn_cast<MemberExpr>(S))
     return getRelativeName(M->getMemberDecl());
   if (auto *I = dyn_cast<IntegerLiteral>(S)) {
     SmallString<256> Str;
     I->getValue().toString(Str, /*Radix=*/10, /*Signed=*/false);
     return Str.str();
   }
   if (auto *F = dyn_cast<FloatingLiteral>(S)) {
     SmallString<256> Str;
     F->getValue().toString(Str);
     return Str.str();
   }
   if (auto *D = dyn_cast<DeclRefExpr>(S))
     return getRelativeName(D->getDecl(), getEnclosingDeclContext(AST, S));
   if (auto *String = dyn_cast<StringLiteral>(S))
     return String->getString();
   if (auto *B = dyn_cast<CXXBoolLiteralExpr>(S))
     return B->getValue() ? "true" : "false";
   return "";
 }
 
 class DataCollector : public ConstDeclVisitor<DataCollector>,
                       public ConstStmtVisitor<DataCollector> {
   const SyntaxTree::Impl &Tree;
   ASTContext &Context;
   llvm::MD5 &DataConsumer;
 
   void addData(const QualType &QT) { addData(QT.getAsString(Tree.TypePP)); }
   template <class T> void addData(T Data) {
     data_collection::addDataToConsumer(DataConsumer, Data);
   }
 
 public:
   DataCollector(const DynTypedNode &DTN, const SyntaxTree::Impl &Tree,
                 llvm::MD5 &DataConsumer)
       : Tree(Tree), Context(Tree.AST.getASTContext()),
         DataConsumer(DataConsumer) {
     if (auto *S = DTN.get<Stmt>())
       ConstStmtVisitor<DataCollector>::Visit(S);
     else if (auto *D = DTN.get<Decl>())
       ConstDeclVisitor<DataCollector>::Visit(D);
+    else if (auto *TL = DTN.get<TypeLoc>())
+      addData(TL->getType());
+    else if (auto *QT = DTN.get<QualType>())
+      addData(*QT);
     else if (auto *Init = DTN.get<CXXCtorInitializer>())
       addData(getInitializerValue(Init, Tree.TypePP));
     else if (auto *Template = DTN.get<TemplateName>())
       addData(dumpToString(*Template));
     else if (auto *Arg = DTN.get<TemplateArgument>())
-      addData(dumpToString(*Arg));
+      ;
     else
       llvm_unreachable("DataConsumer: unhandled AST node.\n");
   }
 
 #define DEF_ADD_DATA(CLASS, CODE)                                              \
   template <class = void> void Visit##CLASS(const CLASS *D) {                  \
     CODE;                                                                      \
     ConstDeclVisitor<DataCollector>::Visit##CLASS(D);                          \
   }
 
 #include "../../AST/DeclDataCollectors.inc"
 
 #define DEF_ADD_DATA(CLASS, CODE)                                              \
   void Visit##CLASS(const CLASS *D) {                                          \
     CODE;                                                                      \
     ConstDeclVisitor<DataCollector>::Visit##CLASS(D);                          \
   }
 
   DEF_ADD_DATA(NamedDecl, { addData(Tree.getRelativeName(D)); })
+  DEF_ADD_DATA(ValueDecl, {})
 #undef DEF_ADD_DATA
 
 #define DEF_ADD_DATA(CLASS, CODE)                                              \
   template <class = void> void Visit##CLASS(const CLASS *S) {                  \
     CODE;                                                                      \
     ConstStmtVisitor<DataCollector>::Visit##CLASS(S);                          \
   }
 
 #include "../../AST/StmtDataCollectors.inc"
 
 #define DEF_ADD_DATA(CLASS, CODE)                                              \
   void Visit##CLASS(const CLASS *S) {                                          \
     CODE;                                                                      \
     ConstStmtVisitor<DataCollector>::Visit##CLASS(S);                          \
   }
 
   // ignore differences of type, because they are not local
   DEF_ADD_DATA(Expr, {})
   DEF_ADD_DATA(DeclRefExpr, {
     addData(Tree.getRelativeName(S->getDecl(),
                                  getEnclosingDeclContext(Tree.AST, S)));
   })
   // For CallExpr nodes, all information is included in its children
   DEF_ADD_DATA(CallExpr, {})
 
 #undef DEF_ADD_DATA
 };
 
 static HashType hashString(StringRef Str) {
   ArrayRef<uint8_t> Data((const uint8_t *)Str.data(), Str.size());
   return llvm::MD5::hash(Data);
 }
 
 HashType SyntaxTree::Impl::hashNode(const Node &N) const {
   const DynTypedNode &DTN = N.ASTNode;
   if (N.isMacro()) {
     CharSourceRange Range(getSourceExtent(AST, N.ASTNode.getSourceRange()),
                           false);
     return hashString(
         Lexer::getSourceText(Range, AST.getSourceManager(), AST.getLangOpts()));
   }
   llvm::MD5 Hash;
   DataCollector(DTN, *this, Hash);
   llvm::MD5::MD5Result HashResult;
   Hash.final(HashResult);
   return HashResult;
 }
 
 SourceRange SyntaxTree::Impl::getSourceRange(const Node &N) const {
   SourceRange Range;
   if (auto *Arg = N.ASTNode.get<TemplateArgument>())
     Range = TemplateArgumentLocations.at(&N - &Nodes[0]);
   else {
     Range = N.ASTNode.getSourceRange();
     if (auto *ThisExpr = N.ASTNode.get<CXXThisExpr>())
       if (ThisExpr->isImplicit())
         Range.setEnd(Range.getBegin());
     // If it is a CXXConstructExpr that is not a temporary, then there is
     // probably an identifier of an initialization that is included in the
     // range. This identifier belongs to the parent node, so stick to the
     // ctor arguments only.
     if (auto *CE = N.ASTNode.get<CXXConstructExpr>())
       if (!isa<CXXTemporaryObjectExpr>(CE))
         Range = CE->getParenOrBraceRange();
   }
   return Range;
 }
 
 /// Identifies a node in a subtree by its postorder offset, starting at 1.
 struct SNodeId {
   int Id = 0;
 
   explicit SNodeId(int Id) : Id(Id) {}
   explicit SNodeId() = default;
 
   operator int() const { return Id; }
   SNodeId &operator++() { return ++Id, *this; }
   SNodeId &operator--() { return --Id, *this; }
   SNodeId operator+(int Other) const { return SNodeId(Id + Other); }
 };
 
 class Subtree {
 private:
   /// The parent tree.
   const SyntaxTree::Impl &Tree;
   /// Maps SNodeIds to original ids.
   std::vector<NodeId> RootIds;
   /// Maps subtree nodes to their leftmost descendants wtihin the subtree.
   std::vector<SNodeId> LeftMostDescendants;
 
 public:
   std::vector<SNodeId> KeyRoots;
 
   Subtree(const SyntaxTree::Impl &Tree, NodeId SubtreeRoot) : Tree(Tree) {
     RootIds = getSubtreePostorder(Tree, SubtreeRoot);
     int NumLeaves = setLeftMostDescendants();
     computeKeyRoots(NumLeaves);
   }
   int getSize() const { return RootIds.size(); }
   NodeId getIdInRoot(SNodeId Id) const {
     assert(Id > 0 && Id <= getSize() && "Invalid subtree node index.");
     return RootIds[Id - 1];
   }
   const Node &getNode(SNodeId Id) const {
     return Tree.getNode(getIdInRoot(Id));
   }
   SNodeId getLeftMostDescendant(SNodeId Id) const {
     assert(Id > 0 && Id <= getSize() && "Invalid subtree node index.");
     return LeftMostDescendants[Id - 1];
   }
   /// Returns the postorder index of the leftmost descendant in the subtree.
   NodeId getPostorderOffset() const {
     return Tree.PostorderIds[getIdInRoot(SNodeId(1))];
   }
   HashType hashNode(SNodeId Id) const {
     return Tree.hashNode(Tree.getNode(getIdInRoot(Id)));
   }
   std::string getNodeValue(SNodeId Id) const {
     return Tree.getNodeValue(getIdInRoot(Id));
   }
 
 private:
   /// Returns the number of leafs in the subtree.
   int setLeftMostDescendants() {
     int NumLeaves = 0;
     LeftMostDescendants.resize(getSize());
     for (int I = 0; I < getSize(); ++I) {
       SNodeId SI(I + 1);
       const Node &N = getNode(SI);
       NumLeaves += N.isLeaf();
       assert(I == Tree.PostorderIds[getIdInRoot(SI)] - getPostorderOffset() &&
              "Postorder traversal in subtree should correspond to traversal in "
              "the root tree by a constant offset.");
       LeftMostDescendants[I] = SNodeId(Tree.PostorderIds[N.LeftMostDescendant] -
                                        getPostorderOffset());
     }
     return NumLeaves;
   }
   void computeKeyRoots(int Leaves) {
     KeyRoots.resize(Leaves);
     std::unordered_set<int> Visited;
     int K = Leaves - 1;
     for (SNodeId I(getSize()); I > 0; --I) {
       SNodeId LeftDesc = getLeftMostDescendant(I);
       if (Visited.count(LeftDesc))
         continue;
       assert(K >= 0 && "K should be non-negative");
       KeyRoots[K] = I;
       Visited.insert(LeftDesc);
       --K;
     }
   }
 };
 
 /// Implementation of Zhang and Shasha's Algorithm for tree edit distance.
 /// Computes an optimal mapping between two trees using only insertion,
 /// deletion and update as edit actions (similar to the Levenshtein distance).
 class ZhangShashaMatcher {
   const ASTDiff::Impl &DiffImpl;
   Subtree S1;
   Subtree S2;
   std::unique_ptr<std::unique_ptr<double[]>[]> TreeDist, ForestDist;
 
 public:
   ZhangShashaMatcher(const ASTDiff::Impl &DiffImpl, const SyntaxTree::Impl &T1,
                      const SyntaxTree::Impl &T2, NodeId Id1, NodeId Id2)
       : DiffImpl(DiffImpl), S1(T1, Id1), S2(T2, Id2) {
     TreeDist = llvm::make_unique<std::unique_ptr<double[]>[]>(
         size_t(S1.getSize()) + 1);
     ForestDist = llvm::make_unique<std::unique_ptr<double[]>[]>(
         size_t(S1.getSize()) + 1);
     for (int I = 0, E = S1.getSize() + 1; I < E; ++I) {
       TreeDist[I] = llvm::make_unique<double[]>(size_t(S2.getSize()) + 1);
       ForestDist[I] = llvm::make_unique<double[]>(size_t(S2.getSize()) + 1);
     }
   }
 
   std::vector<std::pair<NodeId, NodeId>> getMatchingNodes() {
     std::vector<std::pair<NodeId, NodeId>> Matches;
     std::vector<std::pair<SNodeId, SNodeId>> TreePairs;
 
     computeTreeDist();
 
     bool RootNodePair = true;
 
     TreePairs.emplace_back(SNodeId(S1.getSize()), SNodeId(S2.getSize()));
 
     while (!TreePairs.empty()) {
       SNodeId LastRow, LastCol, FirstRow, FirstCol, Row, Col;
       std::tie(LastRow, LastCol) = TreePairs.back();
       TreePairs.pop_back();
 
       if (!RootNodePair) {
         computeForestDist(LastRow, LastCol);
       }
 
       RootNodePair = false;
 
       FirstRow = S1.getLeftMostDescendant(LastRow);
       FirstCol = S2.getLeftMostDescendant(LastCol);
 
       Row = LastRow;
       Col = LastCol;
 
       while (Row > FirstRow || Col > FirstCol) {
         if (Row > FirstRow &&
             ForestDist[Row - 1][Col] + 1 == ForestDist[Row][Col]) {
           --Row;
         } else if (Col > FirstCol &&
                    ForestDist[Row][Col - 1] + 1 == ForestDist[Row][Col]) {
           --Col;
         } else {
           SNodeId LMD1 = S1.getLeftMostDescendant(Row);
           SNodeId LMD2 = S2.getLeftMostDescendant(Col);
           if (LMD1 == S1.getLeftMostDescendant(LastRow) &&
               LMD2 == S2.getLeftMostDescendant(LastCol)) {
             NodeId Id1 = S1.getIdInRoot(Row);
             NodeId Id2 = S2.getIdInRoot(Col);
             assert(DiffImpl.isMatchingPossible(Id1, Id2) &&
                    "These nodes must not be matched.");
             Matches.emplace_back(Id1, Id2);
             --Row;
             --Col;
           } else {
             TreePairs.emplace_back(Row, Col);
             Row = LMD1;
             Col = LMD2;
           }
         }
       }
     }
     return Matches;
   }
 
 private:
   /// We use a simple cost model for edit actions, which seems good enough.
   /// Simple cost model for edit actions. This seems to make the matching
   /// algorithm perform reasonably well.
   /// The values range between 0 and 1, or infinity if this edit action should
   /// always be avoided.
   static constexpr double DeletionCost = 1;
   static constexpr double InsertionCost = 1;
 
   double getUpdateCost(SNodeId Id1, SNodeId Id2) {
     if (!DiffImpl.isMatchingPossible(S1.getIdInRoot(Id1), S2.getIdInRoot(Id2)))
       return std::numeric_limits<double>::max();
     return S1.hashNode(Id1) != S2.hashNode(Id2);
   }
 
   void computeTreeDist() {
     for (SNodeId Id1 : S1.KeyRoots)
       for (SNodeId Id2 : S2.KeyRoots)
         computeForestDist(Id1, Id2);
   }
 
   void computeForestDist(SNodeId Id1, SNodeId Id2) {
     assert(Id1 > 0 && Id2 > 0 && "Expecting offsets greater than 0.");
     SNodeId LMD1 = S1.getLeftMostDescendant(Id1);
     SNodeId LMD2 = S2.getLeftMostDescendant(Id2);
 
     ForestDist[LMD1][LMD2] = 0;
     for (SNodeId D1 = LMD1 + 1; D1 <= Id1; ++D1) {
       ForestDist[D1][LMD2] = ForestDist[D1 - 1][LMD2] + DeletionCost;
       for (SNodeId D2 = LMD2 + 1; D2 <= Id2; ++D2) {
         ForestDist[LMD1][D2] = ForestDist[LMD1][D2 - 1] + InsertionCost;
         SNodeId DLMD1 = S1.getLeftMostDescendant(D1);
         SNodeId DLMD2 = S2.getLeftMostDescendant(D2);
         if (DLMD1 == LMD1 && DLMD2 == LMD2) {
           double UpdateCost = getUpdateCost(D1, D2);
           ForestDist[D1][D2] =
               std::min({ForestDist[D1 - 1][D2] + DeletionCost,
                         ForestDist[D1][D2 - 1] + InsertionCost,
                         ForestDist[D1 - 1][D2 - 1] + UpdateCost});
           TreeDist[D1][D2] = ForestDist[D1][D2];
         } else {
           ForestDist[D1][D2] =
               std::min({ForestDist[D1 - 1][D2] + DeletionCost,
                         ForestDist[D1][D2 - 1] + InsertionCost,
                         ForestDist[DLMD1][DLMD2] + TreeDist[D1][D2]});
         }
       }
     }
   }
 };
 
 ast_type_traits::ASTNodeKind Node::getType() const {
   return ASTNode.getNodeKind();
 }
 
 StringRef Node::getTypeLabel() const {
   if (isMacro())
     return "Macro";
   return getType().asStringRef();
 }
 
 bool Node::isMacro() const {
   return ASTNode.getSourceRange().getBegin().isMacroID();
 }
 
 llvm::Optional<std::string> Node::getQualifiedIdentifier() const {
   if (isMacro())
     return llvm::None;
   if (auto *ND = ASTNode.get<NamedDecl>()) {
     if (ND->getDeclName().isIdentifier())
       return ND->getQualifiedNameAsString();
     else
       return std::string();
   }
   return llvm::None;
 }
 
 llvm::Optional<StringRef> Node::getIdentifier() const {
   if (isMacro())
     return llvm::None;
   if (auto *ND = ASTNode.get<NamedDecl>()) {
     if (ND->getDeclName().isIdentifier())
       return ND->getName();
     else
       return StringRef();
   }
   return llvm::None;
 }
 
 namespace {
 // Compares nodes by their depth.
 struct HeightLess {
   const SyntaxTree::Impl &Tree;
   HeightLess(const SyntaxTree::Impl &Tree) : Tree(Tree) {}
   bool operator()(NodeId Id1, NodeId Id2) const {
     return Tree.getNode(Id1).Height < Tree.getNode(Id2).Height;
   }
 };
 } // end anonymous namespace
 
 namespace {
 // Priority queue for nodes, sorted descendingly by their height.
 class PriorityList {
   const SyntaxTree::Impl &Tree;
   HeightLess Cmp;
   std::vector<NodeId> Container;
   PriorityQueue<NodeId, std::vector<NodeId>, HeightLess> List;
 
 public:
   PriorityList(const SyntaxTree::Impl &Tree)
       : Tree(Tree), Cmp(Tree), List(Cmp, Container) {}
 
   void push(NodeId id) { List.push(id); }
 
   std::vector<NodeId> pop() {
     int Max = peekMax();
     std::vector<NodeId> Result;
     if (Max == 0)
       return Result;
     while (peekMax() == Max) {
       Result.push_back(List.top());
       List.pop();
     }
     // TODO this is here to get a stable output, not a good heuristic
     std::sort(Result.begin(), Result.end());
     return Result;
   }
   int peekMax() const {
     if (List.empty())
       return 0;
     return Tree.getNode(List.top()).Height;
   }
   void open(NodeId Id) {
     for (NodeId Child : Tree.getNode(Id).Children)
       push(Child);
   }
 };
 } // end anonymous namespace
 
 bool ASTDiff::Impl::identical(NodeId Id1, NodeId Id2) const {
   const Node &N1 = T1.getNode(Id1);
   const Node &N2 = T2.getNode(Id2);
   if (N1.Children.size() != N2.Children.size() ||
       !isMatchingPossible(Id1, Id2) || T1.hashNode(N1) != T2.hashNode(N2))
     return false;
   for (size_t Id = 0, E = N1.Children.size(); Id < E; ++Id)
     if (!identical(N1.Children[Id], N2.Children[Id]))
       return false;
   return true;
 }
 
 bool ASTDiff::Impl::isMatchingPossible(NodeId Id1, NodeId Id2) const {
   return Options.isMatchingAllowed(T1.getNode(Id1), T2.getNode(Id2));
 }
 
 bool ASTDiff::Impl::haveSameParents(const Mapping &M, NodeId Id1,
                                     NodeId Id2) const {
   NodeId P1 = T1.getNode(Id1).Parent;
   NodeId P2 = T2.getNode(Id2).Parent;
   return (P1.isInvalid() && P2.isInvalid()) ||
          (P1.isValid() && P2.isValid() && M.getDst(P1) == P2);
 }
 
 void ASTDiff::Impl::addOptimalMapping(Mapping &M, NodeId Id1,
                                       NodeId Id2) const {
   if (std::max(T1.getNumberOfDescendants(Id1), T2.getNumberOfDescendants(Id2)) >
       Options.MaxSize)
     return;
   ZhangShashaMatcher Matcher(*this, T1, T2, Id1, Id2);
   std::vector<std::pair<NodeId, NodeId>> R = Matcher.getMatchingNodes();
   for (const auto Tuple : R) {
     NodeId Src = Tuple.first;
     NodeId Dst = Tuple.second;
     if (!M.hasSrc(Src) && !M.hasDst(Dst))
       M.link(Src, Dst);
   }
 }
 
 double ASTDiff::Impl::getJaccardSimilarity(const Mapping &M, NodeId Id1,
                                            NodeId Id2) const {
   int CommonDescendants = 0;
   const Node &N1 = T1.getNode(Id1);
   // Count the common descendants, excluding the subtree root.
   for (NodeId Src = Id1 + 1; Src <= N1.RightMostDescendant; ++Src) {
     NodeId Dst = M.getDst(Src);
     CommonDescendants += int(Dst.isValid() && T2.isInSubtree(Dst, Id2));
   }
   // We need to subtract 1 to get the number of descendants excluding the root.
   double Denominator = T1.getNumberOfDescendants(Id1) - 1 +
                        T2.getNumberOfDescendants(Id2) - 1 - CommonDescendants;
   // CommonDescendants is less than the size of one subtree.
   assert(Denominator >= 0 && "Expected non-negative denominator.");
   if (Denominator == 0)
     return 0;
   return CommonDescendants / Denominator;
 }
 
 double ASTDiff::Impl::getNodeSimilarity(const Mapping &M, NodeId Id1,
                                         NodeId Id2) const {
   const Node &N1 = T1.getNode(Id1);
   const Node &N2 = T2.getNode(Id2);
   auto Ident1 = N1.getIdentifier(), Ident2 = N2.getIdentifier();
 
   bool SameValue = T1.hashNode(N1) == T2.hashNode(N2);
   auto SameIdent = Ident1 && Ident2 && *Ident1 == *Ident2;
 
   double NodeSimilarity = 0;
   NodeSimilarity += SameValue;
   NodeSimilarity += SameIdent;
 
   assert(haveSameParents(M, Id1, Id2));
   return NodeSimilarity * Options.MinSimilarity;
 }
 
 NodeId ASTDiff::Impl::findCandidate(const Mapping &M, NodeId Id1) const {
   NodeId Candidate;
   double HighestSimilarity = 0.0;
   for (NodeId Id2 : T2) {
     if (!isMatchingPossible(Id1, Id2))
       continue;
     if (M.hasDst(Id2))
       continue;
     double Similarity = getJaccardSimilarity(M, Id1, Id2);
     if (Similarity >= Options.MinSimilarity && Similarity > HighestSimilarity) {
       HighestSimilarity = Similarity;
       Candidate = Id2;
     }
   }
   return Candidate;
 }
 
 NodeId ASTDiff::Impl::findCandidateFromChildren(const Mapping &M, NodeId Id1,
                                                 NodeId P2) const {
   NodeId Candidate;
   double HighestSimilarity = 0.0;
   for (NodeId Id2 : T2.getNode(P2).Children) {
     if (!isMatchingPossible(Id1, Id2))
       continue;
     if (M.hasDst(Id2))
       continue;
     double Similarity = getJaccardSimilarity(M, Id1, Id2);
     Similarity += getNodeSimilarity(M, Id1, Id2);
     if (Similarity >= Options.MinSimilarity && Similarity > HighestSimilarity) {
       HighestSimilarity = Similarity;
       Candidate = Id2;
     }
   }
   return Candidate;
 }
 
 void ASTDiff::Impl::matchBottomUp(Mapping &M) const {
   std::vector<NodeId> Postorder = getSubtreePostorder(T1, T1.getRootId());
   for (NodeId Id1 : Postorder) {
     if (Id1 == T1.getRootId() && !M.hasSrc(T1.getRootId()) &&
         !M.hasDst(T2.getRootId())) {
       if (isMatchingPossible(T1.getRootId(), T2.getRootId())) {
         M.link(T1.getRootId(), T2.getRootId());
         addOptimalMapping(M, T1.getRootId(), T2.getRootId());
       }
       break;
     }
     bool Matched = M.hasSrc(Id1);
     const Node &N1 = T1.getNode(Id1);
     bool MatchedChildren =
         std::any_of(N1.Children.begin(), N1.Children.end(),
                     [&](NodeId Child) { return M.hasSrc(Child); });
     if (Matched || !MatchedChildren)
       continue;
     NodeId Id2 = findCandidate(M, Id1);
     if (Id2.isValid()) {
       M.link(Id1, Id2);
       addOptimalMapping(M, Id1, Id2);
     }
   }
 }
 
 void ASTDiff::Impl::matchChildren(Mapping &M) {
   for (NodeId Id1 : T1) {
     NodeId P1 = T1.getNode(Id1).Parent;
     if (P1.isInvalid() || !M.hasSrc(P1))
       continue;
     if (M.hasSrc(Id1))
       continue;
     NodeId P2 = M.getDst(P1);
     NodeId Id2 = findCandidateFromChildren(M, Id1, P2);
     if (Id2.isValid()) {
       M.link(Id1, Id2);
       addOptimalMapping(M, Id1, Id2);
     }
   }
 }
 
 Mapping ASTDiff::Impl::matchTopDown() const {
   PriorityList L1(T1);
   PriorityList L2(T2);
 
   Mapping M(T1.getSize() + T2.getSize());
 
   L1.push(T1.getRootId());
   L2.push(T2.getRootId());
 
   int Max1, Max2;
   while (std::min(Max1 = L1.peekMax(), Max2 = L2.peekMax()) >
          Options.MinHeight) {
     if (Max1 > Max2) {
       for (NodeId Id : L1.pop())
         L1.open(Id);
       continue;
     }
     if (Max2 > Max1) {
       for (NodeId Id : L2.pop())
         L2.open(Id);
       continue;
     }
     std::vector<NodeId> H1, H2;
     H1 = L1.pop();
     H2 = L2.pop();
     for (NodeId Id1 : H1) {
       for (NodeId Id2 : H2) {
         if (identical(Id1, Id2) && !M.hasSrc(Id1) && !M.hasDst(Id2)) {
           for (int I = 0, E = T1.getNumberOfDescendants(Id1); I < E; ++I)
             M.link(Id1 + I, Id2 + I);
         }
       }
     }
     for (NodeId Id1 : H1) {
       if (!M.hasSrc(Id1))
         L1.open(Id1);
     }
     for (NodeId Id2 : H2) {
       if (!M.hasDst(Id2))
         L2.open(Id2);
     }
   }
   return M;
 }
 
 ASTDiff::Impl::Impl(SyntaxTree::Impl &T1, SyntaxTree::Impl &T2,
                     const ComparisonOptions &Options)
     : T1(T1), T2(T2), Options(Options) {
   computeMapping();
   computeChangeKinds(TheMapping);
 }
 
 void ASTDiff::Impl::computeMapping() {
   TheMapping = matchTopDown();
   if (Options.StopAfterTopDown)
     return;
   matchBottomUp(TheMapping);
   if (Options.StopAfterBottomUp)
     return;
   matchChildren(TheMapping);
 }
 
 void ASTDiff::Impl::computeChangeKinds(Mapping &M) {
   for (NodeId Id1 : T1) {
     if (!M.hasSrc(Id1)) {
       T1.getMutableNode(Id1).Change = Delete;
       T1.getMutableNode(Id1).Shift -= 1;
     }
   }
   for (NodeId Id2 : T2) {
     if (!M.hasDst(Id2)) {
       T2.getMutableNode(Id2).Change = Insert;
       T2.getMutableNode(Id2).Shift -= 1;
     }
   }
   for (NodeId Id1 : T1.NodesBfs) {
     NodeId Id2 = M.getDst(Id1);
     if (Id2.isInvalid())
       continue;
     if (!haveSameParents(M, Id1, Id2) ||
         T1.findPositionInParent(Id1, true) !=
             T2.findPositionInParent(Id2, true)) {
       T1.getMutableNode(Id1).Shift -= 1;
       T2.getMutableNode(Id2).Shift -= 1;
     }
   }
   for (NodeId Id2 : T2.NodesBfs) {
     NodeId Id1 = M.getSrc(Id2);
     if (Id1.isInvalid())
       continue;
     Node &N1 = T1.getMutableNode(Id1);
     Node &N2 = T2.getMutableNode(Id2);
     if (Id1.isInvalid())
       continue;
     if (!haveSameParents(M, Id1, Id2) ||
         T1.findPositionInParent(Id1, true) !=
             T2.findPositionInParent(Id2, true)) {
       N1.Change = N2.Change = Move;
     }
     if (T1.hashNode(N1) != T2.hashNode(N2))
       N1.Change = N2.Change = (N1.Change == Move ? UpdateMove : Update);
   }
 }
 
 ASTDiff::ASTDiff(SyntaxTree &T1, SyntaxTree &T2,
                  const ComparisonOptions &Options)
     : DiffImpl(llvm::make_unique<Impl>(*T1.TreeImpl, *T2.TreeImpl, Options)) {}
 
 ASTDiff::~ASTDiff() = default;
 
 NodeId ASTDiff::getMapped(const SyntaxTree &SourceTree, NodeId Id) const {
   return DiffImpl->getMapped(SourceTree.TreeImpl, Id);
 }
 
 SyntaxTree::SyntaxTree() : TreeImpl(nullptr) {}
 
 SyntaxTree::SyntaxTree(ASTUnit &AST)
     : TreeImpl(llvm::make_unique<SyntaxTree::Impl>(
           this, AST.getASTContext().getTranslationUnitDecl(), AST)) {}
 
 SyntaxTree::SyntaxTree(SyntaxTree &&Other) = default;
 
 SyntaxTree &SyntaxTree::operator=(SyntaxTree &&Other) = default;
 
 SyntaxTree::SyntaxTree(const SyntaxTree &Other)
     : TreeImpl(llvm::make_unique<SyntaxTree::Impl>(this, *Other.TreeImpl)) {}
 
 SyntaxTree::~SyntaxTree() = default;
 
 ASTUnit &SyntaxTree::getASTUnit() const { return TreeImpl->AST; }
 
 SourceManager &SyntaxTree::getSourceManager() const {
   return TreeImpl->AST.getSourceManager();
 }
 
 const LangOptions &SyntaxTree::getLangOpts() const {
   return TreeImpl->AST.getLangOpts();
 }
 
 const ASTContext &SyntaxTree::getASTContext() const {
   return TreeImpl->AST.getASTContext();
 }
 
 const Node &SyntaxTree::getNode(NodeId Id) const {
   return TreeImpl->getNode(Id);
 }
 
 int SyntaxTree::getSize() const { return TreeImpl->getSize(); }
 NodeId SyntaxTree::getRootId() const { return TreeImpl->getRootId(); }
 SyntaxTree::PreorderIterator SyntaxTree::begin() const {
   return TreeImpl->begin();
 }
 SyntaxTree::PreorderIterator SyntaxTree::end() const { return TreeImpl->end(); }
 
 int SyntaxTree::findPositionInParent(NodeId Id) const {
   return TreeImpl->findPositionInParent(Id);
 }
 
 SourceRange SyntaxTree::getSourceRange(const Node &N) const {
   return TreeImpl->getSourceRange(N);
 }
 
 std::pair<unsigned, unsigned>
 SyntaxTree::getSourceRangeOffsets(const Node &N) const {
   const SourceManager &SrcMgr = TreeImpl->AST.getSourceManager();
   SourceRange Range =
       getSourceExtent(TreeImpl->AST, TreeImpl->getSourceRange(N));
   unsigned Begin = SrcMgr.getFileOffset(Range.getBegin());
   unsigned End = SrcMgr.getFileOffset(Range.getEnd());
   return {Begin, End};
 }
 
 std::string SyntaxTree::getNodeValue(NodeId Id) const {
   return TreeImpl->getNodeValue(Id);
 }
 
 std::string SyntaxTree::getNodeValue(const Node &N) const {
   return TreeImpl->getNodeValue(N);
 }
 
 } // end namespace diff
 } // end namespace clang
diff --git a/test/Tooling/clang-diff-ast.cpp b/test/Tooling/clang-diff-ast.cpp
index 169cb3e81e..2a4830459a 100644
--- a/test/Tooling/clang-diff-ast.cpp
+++ b/test/Tooling/clang-diff-ast.cpp
@@ -1,107 +1,120 @@
 // RUN: clang-diff -ast-dump %s -- -std=c++11 | FileCheck %s
 
 
 // CHECK: {{^}}TranslationUnitDecl(0)
-// CHECK: {{^}} NamespaceDecl: test;(
+// CHECK: {{^}} NamespaceDecl: test(
 namespace test {
 
 // CHECK: {{^}} FunctionDecl: :f(
 // CHECK: CompoundStmt(
 void f() {
-  // CHECK: VarDecl: i(int)(
-  // CHECK: IntegerLiteral: 1
+  // CHECK: VarDecl: i(
+  // CHECK-NEXT: TypeLoc: auto
+  // CHECK-NEXT: QualType: NULL TYPE
+  // CHECK-NEXT: IntegerLiteral: 1
   auto i = 1;
   // CHECK: FloatingLiteral: 1.5(
   auto r = 1.5;
-  // CHECK: CXXBoolLiteralExpr: true(
-  auto b = true;
+  // CHECK: TypeLoc: _Bool
+  // CHECK-NEXT: CXXBoolLiteralExpr: true(
+  bool b = true;
   // CHECK: CallExpr(
   // CHECK-NOT: ImplicitCastExpr
   // CHECK: DeclRefExpr: :f(
   f();
   // CHECK: UnaryOperator: ++(
   ++i;
   // CHECK: BinaryOperator: =(
   i = i;
 }
 
 } // end namespace test
 
 // CHECK: UsingDirectiveDecl: test(
 using namespace test;
 
-// CHECK: TypedefDecl: nat;unsigned int;(
+// CHECK: TypedefDecl: nat(
 typedef unsigned nat;
-// CHECK: TypeAliasDecl: real;double;(
+// CHECK: TypeAliasDecl: real(
 using real = double;
 
 class Base {
 };
 
-// CHECK: CXXRecordDecl: X;X;(
+// CHECK: CXXRecordDecl: X(
 class X : Base {
   int m;
-  // CHECK: CXXMethodDecl: :foo(const char *(int)
-  // CHECK: ParmVarDecl: i(int)(
+  // CHECK: CXXMethodDecl: :foo(
+  // CHECK: ParmVarDecl: i(
   const char *foo(int i) {
     if (i == 0)
       // CHECK: StringLiteral: foo(
       return "foo";
     // CHECK-NOT: ImplicitCastExpr
     return 0;
   }
 
   // CHECK: AccessSpecDecl: public(
 public:
   int not_initialized;
-  // CHECK: CXXConstructorDecl: :X(void (char, int){{( __attribute__\(\(thiscall\)\))?}})(
-  // CHECK-NEXT: ParmVarDecl: s(char)
-  // CHECK-NEXT: ParmVarDecl: (int)
-  // CHECK-NEXT: CXXCtorInitializer: Base
+  // CHECK: CXXConstructorDecl: :X(
+  // CHECK-NEXT: TypeLoc: void (char, int
+  // CHECK-NEXT: TypeLoc: void
+  // CHECK-NEXT: ParmVarDecl: s
+  // CHECK-NEXT: TypeLoc: char
+  // CHECK-NEXT: ParmVarDecl(
+  // CHECK-NEXT: TypeLoc: int
+  // CHECK-NEXT: CXXCtorInitializer:
+  // CHECK-NEXT: TypeLoc: class Base
   // CHECK-NEXT: CXXConstructExpr
   // CHECK-NEXT: CXXCtorInitializer: m
   // CHECK-NEXT: IntegerLiteral: 0
   X(char s, int) : Base(), m(0) {
     // CHECK-NEXT: CompoundStmt
     // CHECK: MemberExpr: :m(
     int x = m;
   }
-  // CHECK: CXXConstructorDecl: :X(void (char){{( __attribute__\(\(thiscall\)\))?}})(
+  // CHECK: CXXConstructorDecl: :X(
   // CHECK: CXXCtorInitializer: X
   X(char s) : X(s, 4) {}
 };
 
 #define M (void)1
 #define F(a, b) (void)a, b
 void macros() {
   // CHECK: Macro: M(
   M;
+  // CHECK-NEXT: Macro: M(
   // two expressions, therefore it occurs twice
   // CHECK-NEXT: Macro: F(1, 2)(
   // CHECK-NEXT: Macro: F(1, 2)(
+  // CHECK-NEXT: Macro: F(1, 2)(
   F(1, 2);
 }
 
 #ifndef GUARD
 #define GUARD
 // CHECK-NEXT: NamespaceDecl
 namespace world {
 // nodes from other files are excluded, there should be no output here
 #include "clang-diff-ast.cpp"
 }
 // CHECK-NEXT: FunctionDecl: sentinel
 void sentinel();
 #endif
 
-// CHECK-NEXT: ClassTemplateDecl: C
+// CHECK: ClassTemplateDecl: C
 // CHECK-NEXT: TemplateTypeParmDecl
+// CHECK-NEXT: QualType: T
 // CHECK-NEXT: CXXRecordDecl
 template <class T> class C {
   // CHECK-NEXT: FieldDecl
+  // CHECK-NEXT: TypeLoc: T
   T t;
 };
 
 // CHECK-NEXT: CXXRecordDecl
+// CHECK-NEXT: TypeLoc: C<int>
 // CHECK-NEXT: TemplateName
 // CHECK-NEXT: TemplateArgument
 class I : C<int> {};
diff --git a/test/Tooling/clang-diff-basic.cpp b/test/Tooling/clang-diff-basic.cpp
index 0c8a5b5e05..12bd21a1d9 100644
--- a/test/Tooling/clang-diff-basic.cpp
+++ b/test/Tooling/clang-diff-basic.cpp
@@ -1,107 +1,108 @@
 // RUN: clang-diff -dump-matches %S/Inputs/clang-diff-basic-src.cpp %s -s=200 -- -std=c++11 | FileCheck %s
 
 // CHECK: Match TranslationUnitDecl{{.*}} to TranslationUnitDecl
 // CHECK: Match NamespaceDecl: src{{.*}} to NamespaceDecl: dst
 namespace dst {
 // CHECK-NOT: Match NamespaceDecl: src{{.*}} to NamespaceDecl: inner
 namespace inner {
 void foo() {
   // CHECK: Match IntegerLiteral: 321{{.*}} to IntegerLiteral: 322
   int x = 322;
 }
 }
 
 // CHECK: Match DeclRefExpr: :foo{{.*}} to DeclRefExpr: :inner::foo
 void main() { inner::foo(); }
 
 // CHECK: Match StringLiteral: foo{{.*}} to StringLiteral: foo
 const char *b = "f" "o" "o";
 
 // unsigned is canonicalized to unsigned int
-// CHECK: Match TypedefDecl: :nat;unsigned int;{{.*}} to TypedefDecl: :nat;unsigned int;
+// CHECK: Match TypedefDecl: :nat{{.*}} to TypedefDecl: :nat
 typedef unsigned nat;
 
-// CHECK: Match VarDecl: :p(int){{.*}} to VarDecl: :prod(double)
-// CHECK: Update VarDecl: :p(int){{.*}} to :prod(double)
+// CHECK: Match VarDecl: :p{{.*}} to VarDecl: :prod
+// CHECK: Update VarDecl: :p{{.*}} to :prod
+// CHECK: Update TypeLoc: int{{.*}} to double
 // CHECK: Match BinaryOperator: *{{.*}} to BinaryOperator: *
 double prod = 1 * 2 * 10;
 // CHECK: Update DeclRefExpr
 int squared = prod * prod;
 
 class X {
   const char *foo(int i) {
     if (i == 0)
       return "Bar";
     // CHECK: Insert IfStmt{{.*}} into IfStmt
     // CHECK: Insert BinaryOperator: =={{.*}} into IfStmt
     else if (i == -1)
       return "foo";
     return 0;
   }
   X(){}
 };
 }
 
 // CHECK: Move CompoundStmt{{.*}} into CompoundStmt
 void m() { { int x = 0 + 0 + 0; } }
 // CHECK: Update and Move IntegerLiteral: 7{{.*}} into BinaryOperator: +({{.*}}) at 1
 int um = 1 + 7;
 
 namespace {
 // match with parents of different type
 // CHECK: Match FunctionDecl: f1{{.*}} to FunctionDecl: (anonymous namespace)::f1
 void f1() {{ (void) __func__;;; }}
 }
 
 // macros are always compared by their full textual value
 
 #define M1 return 1 + 1
 #define M2 return 2 * 2
 #define F(a, b) return a + b;
 
 int f2() {
   // CHECK: Match Macro: M1{{.*}} to Macro: M1
   M1;
   // CHECK: Update Macro: M1{{.*}} to M2
   M2;
   // CHECK: Update Macro: F(1, 1){{.*}} to F(1, /*b=*/1)
   F(1, /*b=*/1);
 }
 
 // CHECK: Update TemplateTypeParmDecl: T{{.*}} to Type
 template <class Type, class U = int>
 U visit(Type &t) {
   int x = t;
   return U();
 }
 
 void tmp() {
   long x;
-  // CHECK: Update TemplateArgument: int{{.*}} to long
+  // CHECK: Update TypeLoc: int{{.*}} to long
   visit<long>(x);
 }
 
 struct str {
   str& operator+(const str&);
   str& operator-(const str&);
   str& operator++();
   str operator++(int);
 } s1, s2, s3;
 
 // CHECK: Match CXXOperatorCallExpr
 // CHECK-NEXT: Match CXXOperatorCallExpr
 // CHECK-NEXT: Match DeclRefExpr: s1
 // CHECK-NEXT: Match DeclRefExpr: str::operator+{{.*}} to DeclRefExpr: str::operator+
 // CHECK-NEXT: Match DeclRefExpr: s2
 // CHECK-NEXT: Match DeclRefExpr: str::operator-{{.*}} to DeclRefExpr: str::operator-
 // CHECK-NEXT: Match DeclRefExpr: s3
 str x = s1 + s2 - s3;
 
 class S {}; class T {};
 void cons() {
   T t;
   (void) T();
 }
 
 // CHECK: Delete AccessSpecDecl: public
 // CHECK: Delete CXXMethodDecl
diff --git a/test/Tooling/clang-diff-bottomup.cpp b/test/Tooling/clang-diff-bottomup.cpp
index 3b98c02475..fab1a8b05c 100644
--- a/test/Tooling/clang-diff-bottomup.cpp
+++ b/test/Tooling/clang-diff-bottomup.cpp
@@ -1,39 +1,37 @@
 // RUN: %clang_cc1 -E %s > %t.src.cpp
 // RUN: %clang_cc1 -E %s > %t.dst.cpp -DDEST
 // RUN: clang-diff -dump-matches -s=0 -stop-diff-after=bottomup %t.src.cpp %t.dst.cpp -- | FileCheck %s
 //
 // Test the bottom-up matching, with maxsize set to 0, so that the optimal matching will never be applied.
 
 #ifndef DEST
 
-void f1() { ; {{;}} }
-void f2() { ;; {{;}} }
+void f1(int) { ; {{;}} }
+void f2(int) { ;; {{;}} }
 
 #else
 
 // Jaccard similarity threshold is 0.5.
 
 void f1() {
 // CompoundStmt: 3 matched descendants, subtree sizes 4 and 5
 // Jaccard similarity = 3 / (4 + 5 - 3) = 3 / 6 >= 0.5
-// CHECK: Match FunctionDecl: f1(void ())(1) to FunctionDecl: f1(void ())(1)
-// CHECK: Match CompoundStmt(2) to CompoundStmt(2)
-// CHECK: Match CompoundStmt(4) to CompoundStmt(3)
-// CHECK: Match CompoundStmt(5) to CompoundStmt(4)
-// CHECK: Match NullStmt(6) to NullStmt(5)
+// CHECK: Match CompoundStmt(6) to CompoundStmt(4)
+// CHECK: Match CompoundStmt({{.*}}) to CompoundStmt({{.*}})
+// CHECK: Match CompoundStmt({{.*}}) to CompoundStmt({{.*}})
+// CHECK: Match NullStmt({{.*}}) to NullStmt({{.*}})
   {{;}} ;;
 }
 
 void f2() {
 // CompoundStmt: 3 matched descendants, subtree sizes 4 and 5
 // Jaccard similarity = 3 / (5 + 6 - 3) = 3 / 8 < 0.5
-// CHECK-NOT: Match FunctionDecl(9)
-// CHECK-NOT: Match CompoundStmt(10)
-// CHECK: Match CompoundStmt(11) to CompoundStmt(10)
-// CHECK: Match CompoundStmt(12) to CompoundStmt(11)
-// CHECK: Match NullStmt(13) to NullStmt(12)
-// CHECK-NOT: Match NullStmt(13)
+// CHECK-NOT: Match CompoundStmt(16)
+// CHECK: Match CompoundStmt({{.*}}) to CompoundStmt({{.*}})
+// CHECK: Match CompoundStmt({{.*}}) to CompoundStmt({{.*}})
+// CHECK: Match NullStmt({{.*}}) to NullStmt({{.*}})
+// CHECK-NOT: Match NullStmt({{.*}})
   {{;}} ;;;
 }
 
 #endif
diff --git a/test/Tooling/clang-diff-heuristics.cpp b/test/Tooling/clang-diff-heuristics.cpp
index 40e0c4b638..90a3aa7f0f 100644
--- a/test/Tooling/clang-diff-heuristics.cpp
+++ b/test/Tooling/clang-diff-heuristics.cpp
@@ -1,31 +1,31 @@
 // RUN: %clang_cc1 -E %s > %t.src.cpp
 // RUN: %clang_cc1 -E %s > %t.dst.cpp -DDEST
 // RUN: clang-diff -dump-matches -s=0 %t.src.cpp %t.dst.cpp -- | FileCheck %s
 //
 // Test the heuristics, with maxsize set to 0, so that the optimal matching will never be applied.
 
 #ifndef DEST
 
 void f1() {;}
 
 void f2(int) {;}
 
 class C3 { C3(); };
 
 #else
 
 // same parents, same value
-// CHECK: Match FunctionDecl: f1(void ())(1) to FunctionDecl: f1(void ())(1)
+// CHECK: Match FunctionDecl: f1({{.*}}) to FunctionDecl: f1({{.*}})
 // CHECK: Match CompoundStmt
 void f1() {}
 
 // same parents, same identifier
-// CHECK: Match FunctionDecl: f2(void (int))(4) to FunctionDecl: f2(void ())(3)
+// CHECK: Match FunctionDecl: f2({{.*}}) to FunctionDecl: f2({{.*}})
 // CHECK: Match CompoundStmt
 void f2() {}
 
 // same parents, same identifier
-// CHECK: Match CXXConstructorDecl: :C3(void ())(9) to CXXConstructorDecl: :C3(void (int))(6)
+// CHECK: Match CXXConstructorDecl: :C3({{.*}}) to CXXConstructorDecl: :C3({{.*}})
 class C3 { C3(int); };
 
 #endif
diff --git a/test/Tooling/clang-diff-html.test b/test/Tooling/clang-diff-html.test
index abab46cf50..8bb45a0634 100644
--- a/test/Tooling/clang-diff-html.test
+++ b/test/Tooling/clang-diff-html.test
@@ -1,57 +1,59 @@
 RUN: clang-diff -html %S/Inputs/clang-diff-basic-src.cpp %S/clang-diff-basic.cpp -s=200 -- -std=c++11 | FileCheck %s
 
 CHECK: <pre><div id='L' class='code'>{{.*}}<span id='L0' tid='R0' title='TranslationUnitDecl
 CHECK-NEXT: 0 -> 0' class='node'>
 
 match, update
 CHECK: <span id='L[[L:[0-9]+]]' tid='R[[R:[0-9]+]]' title='Update NamespaceDecl
-CHECK-NEXT: [[L]] -> [[R]]' class='node u'><span class='tree u'> NamespaceDecl: src;
+CHECK-NEXT: [[L]] -> [[R]]' class='node u'><span class='tree u'> NamespaceDecl: src
 CHECK-NEXT: </span><span class='src u'>namespace src {
 
 match, move
 CHECK: <span id='L[[L:[0-9]+]]' tid='R[[R:[0-9]+]]' title='Move FunctionDecl
 CHECK-NEXT: [[L]] -> [[R]]' class='node m'>
-CHECK-NEXT: <span class='src m'>void foo()
+CHECK-NEXT: <span class='src m'></span><span id='L[[L:[0-9]+]]' tid='R[[R:[0-9]+]]' title='TypeLoc
+CHECK: <span class='src'>void</span>{{.*}}<span class='src'> foo()</span>
 
 match
 CHECK: <span id='L[[L:[0-9]+]]' tid='R[[R:[0-9]+]]' title='FunctionDecl
 CHECK-NEXT: [[L]] -> [[R]]' class='node'>
-CHECK-NEXT: <span class='src'>void main()
+CHECK: <span class='src'>void</span>
+CHECK: <span class='src'> main()</span>
 
 deletion
 CHECK: <span id='L[[L:[0-9]+]]' tid='R-1' title='Delete IntegerLiteral
 CHECK-NEXT: [[L]] -> -1' class='node d'><span class='tree d'> IntegerLiteral: 4
 CHECK-NEXT: </span><span class='src d'>4</span>
 
 update + move
 CHECK: class='src u m'>2</span>
 
 VarDecl of same type but different variable name
 ensure that only the latter is marked changed
 CHECK: VarDecl: s
 CHECK: TypeLoc: class T
 CHECK-NEXT: <span class='src'>T</span>{{.*}}CXXConstructExpr
 CHECK-NEXT: CXXConstructExpr
 CHECK: <span class='src u'> s</span>
 CHECK: CXXTemporaryObjectExpr
 CHECK-NEXT: CXXTemporaryObjectExpr
 CHECK-NEXT: <span class='src'></span>
 CHECK-NEXT: TypeLoc: class S
 CHECK-NEXT: <span class='src u'>S</span>
 
 
 insertion
 CHECK: <span id='R[[R:[0-9]+]]' tid='L-1' title='Insert StringLiteral
 CHECK-NEXT: -1 -> [[R]]' class='node i'>
 CHECK-NEXT: <span class='src i'>&quot;Bar&quot;</span>
 
 CHECK: CXXOperatorCallExpr
 CHECK: CXXOperatorCallExpr
 CHECK: s1
 CHECK: str::operator+
 CHECK: s2
 CHECK: str::operator-
 CHECK: s3
 
 comments
 CHECK: // CHECK: Delete AccessSpecDecl: public
diff --git a/test/Tooling/clang-diff-json.cpp b/test/Tooling/clang-diff-json.cpp
index 9aac6fa8b1..742d4e79cc 100644
--- a/test/Tooling/clang-diff-json.cpp
+++ b/test/Tooling/clang-diff-json.cpp
@@ -1,27 +1,26 @@
 // RUN: clang-diff -ast-dump-json %s -- \
 // RUN: | %python -c 'import json, sys; json.dump(json.loads(sys.stdin.read()), sys.stdout, sort_keys=True, indent=2)' \
 // RUN: | FileCheck %s
 
 // CHECK: "begin": 299,
 // CHECK: "type": "FieldDecl",
 // CHECK: "end": 319,
 // CHECK: "type": "CXXRecordDecl",
 class A {
   int x;
 };
 
 // CHECK: "children": [
 // CHECK-NEXT: {
 // CHECK-NEXT: "begin":
 // CHECK-NEXT: "children": []
 // CHECK-NEXT: "end":
 // CHECK-NEXT: "id":
-// CHECK-NEXT: "type": "CharacterLiteral"
-// CHECK-NEXT: }
+// CHECK-NEXT: "type": "TypeLoc"
+// CHECK: }
 // CHECK: ]
 // CHECK: "type": "VarDecl",
 char nl = '\n';
 
 // CHECK: "value": "abc \n\t\u0000\u001f"
 char s[] = "abc \n\t\0\x1f";
-
diff --git a/test/Tooling/clang-diff-opt.cpp b/test/Tooling/clang-diff-opt.cpp
index 0570398c8d..41941b217f 100644
--- a/test/Tooling/clang-diff-opt.cpp
+++ b/test/Tooling/clang-diff-opt.cpp
@@ -1,45 +1,45 @@
 // RUN: %clang_cc1 -E %s > %t.src.cpp
 // RUN: %clang_cc1 -E %s > %t.dst.cpp -DDEST
 // RUN: clang-diff -dump-matches -s=10 -stop-diff-after=bottomup %t.src.cpp %t.dst.cpp -- | FileCheck %s
 //
 // Test the behaviour of the matching according to the optimal tree edit
 // distance, implemented with Zhang and Shasha's algorithm.
 // Just for testing we use a tiny value of 10 for maxsize. Subtrees bigger than
 // this size will not be processed by the optimal algorithm.
 
 #ifndef DEST
 
 void f1() { {;} {{;}} }
 
 void f2() { {;} {{;;;;;}} }
 
 void f3() { {;} {{;;;;;;}} }
 
 #else
 
 void f1() {
 // Jaccard similarity = 3 / (5 + 4 - 3) = 3 / 6 >= 0.5
 // The optimal matching algorithm should move the ; into the outer block
-// CHECK: Match CompoundStmt(2) to CompoundStmt(2)
+// CHECK: Match CompoundStmt(4) to CompoundStmt(4)
 // CHECK-NOT: Match CompoundStmt(3)
-// CHECK-NEXT: Match NullStmt(4) to NullStmt(3)
+// CHECK-NEXT: Match NullStmt(6) to NullStmt(5)
   ; {{;}}
 }
 
 void f2() {
   // Jaccard similarity = 7 / (10 + 10 - 7) >= 0.5
   // As none of the subtrees is bigger than 10 nodes, the optimal algorithm
   // will be run.
-  // CHECK: Match NullStmt(11) to NullStmt(9)
+  // CHECK: Match NullStmt(15) to NullStmt(13)
   ;; {{;;;;;}}
 }
 
 void f3() {
   // Jaccard similarity = 8 / (11 + 11 - 8) >= 0.5
   // As the subtrees are bigger than 10 nodes, the optimal algorithm will not
   // be run.
-  // CHECK: Delete NullStmt(22)
+  // CHECK: Delete NullStmt(28)
   ;; {{;;;;;;}}
 }
 
 #endif
diff --git a/test/Tooling/clang-diff-topdown.cpp b/test/Tooling/clang-diff-topdown.cpp
index d6c1d77033..3b223cd577 100644
--- a/test/Tooling/clang-diff-topdown.cpp
+++ b/test/Tooling/clang-diff-topdown.cpp
@@ -1,83 +1,85 @@
 // RUN: %clang_cc1 -E %s > %t.src.cpp
 // RUN: %clang_cc1 -E %s > %t.dst.cpp -DDEST
 // RUN: clang-diff -dump-matches -stop-diff-after=topdown %t.src.cpp %t.dst.cpp -- -std=c++11 | FileCheck %s
 //
 // Test the top-down matching of identical subtrees only.
 
 #ifndef DEST
 
 void f1()
 {
   // Match some subtree of height greater than 2.
-  // CHECK: Match CompoundStmt(3) to CompoundStmt(3)
-  // CHECK: Match CompoundStmt(4) to CompoundStmt(4)
-  // CHECK: Match NullStmt(5) to NullStmt(5)
+  // CHECK: Match CompoundStmt(5) to CompoundStmt(5)
+  // CHECK-NEXT: Move CompoundStmt
+  // CHECK-NEXT: Match CompoundStmt
+  // CHECK-NEXT: Match NullStmt({{.*}}) to NullStmt({{.*}})
   {{;}}
 
   // Don't match subtrees that are smaller.
   // CHECK-NOT: Match CompoundStmt(6)
   // CHECK-NOT: Match NullStmt(7)
   {;}
 
   // Greedy approach - use the first matching subtree when there are multiple
   // identical subtrees.
-  // CHECK: Match CompoundStmt(8) to CompoundStmt(8)
-  // CHECK: Match CompoundStmt(9) to CompoundStmt(9)
-  // CHECK: Match NullStmt(10) to NullStmt(10)
+  // CHECK: Match CompoundStmt(10) to CompoundStmt(10)
+  // CHECK-NEXT: Move CompoundStmt
+  // CHECK-NEXT: Match CompoundStmt({{.*}}) to CompoundStmt({{.*}})
+  // CHECK-NEXT: Match NullStmt({{.*}}) to NullStmt({{.*}})
   {{;;}}
 }
 
 int x;
 
 namespace src {
   int x;
   int x1 = x + 1;
   int x2 = ::x + 1;
 }
 
 class A { int x = 1 + 1; void f() { int x1 = x; } };
 
 #else
 
 
 void f1() {
 
   {{;}}
 
   {;}
 
   {{;;}}
-  // CHECK-NOT: Match {{.*}} to CompoundStmt(11)
-  // CHECK-NOT: Match {{.*}} to CompoundStmt(12)
-  // CHECK-NOT: Match {{.*}} to NullStmt(13)
+  // CHECK-NOT: Match {{.*}} to CompoundStmt(15)
+  // CHECK-NOT: Match {{.*}} to CompoundStmt(16)
+  // CHECK-NOT: Match {{.*}} to NullStmt(17)
   {{;;}}
 
-  // CHECK-NOT: Match {{.*}} to NullStmt(14)
+  // CHECK-NOT: Match {{.*}} to NullStmt(18)
   ;
 }
 
 int x;
 
 namespace dst {
   int x;
-  // CHECK: Match DeclRefExpr: :x(17) to DeclRefExpr: :x(22)
+  // CHECK: Match DeclRefExpr: :x(22) to DeclRefExpr: :x(27)
   int x1 = x + 1;
-  // CHECK: Match DeclRefExpr: x(21) to DeclRefExpr: x(26)
+  // CHECK: Match DeclRefExpr: x({{.*}}) to DeclRefExpr: x({{.*}})
   int x2 = ::x + 1;
 }
 
 class B {
   // Only the class name changed; it is not included in the field value,
   // therefore there is no update.
-  // CHECK: Match FieldDecl: :x(int)(24) to FieldDecl: :x(int)(29)
-  // CHECK-NOT: Update FieldDecl: :x(int)(24)
+  // CHECK: Match FieldDecl: :x(30) to FieldDecl: :x(35)
+  // CHECK-NOT: Update FieldDecl: :x(int)
   int x = 1+1;
   void f() {
-    // CHECK: Match MemberExpr: :x(32) to MemberExpr: :x(37)
-    // CHECK-NOT: Update MemberExpr: :x(32)
+    // This is not matched even though the expressions are equivalent
+    // CHECK-NOT: Match MemberExpr: :x
     int x1 = B::x;
   }
 
 };
 
 #endif
-- 
2.14.1

